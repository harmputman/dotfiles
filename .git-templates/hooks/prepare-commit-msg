#!/bin/bash

# This script is intended to be used as a Git commit-msg hook.
# It automatically prefixes commit messages based on the current branch name using gitmoji specifications.
# https://gitmoji.dev/specification
#
# Template: <intention>? [scope?][:?] <message>
# - intention: a gitmoji. (optional)
# - scope: Uppercase Jira issue code from branch name (e.g., PROJ-123). (optional)
# - message: The original commit message content.

# File containing the commit message (passed as the first argument to the hook)
FILE=$1

# Read the original commit message content
[[ $FILE != "" ]] && MESSAGE=$(cat "$FILE") || MESSAGE=""

# Exit if message already matches the format: optional emoji, optional [SCOPE]:, then message
export __CHECK_STR="$MESSAGE"
if osascript -l JavaScript -e '
  ObjC.import("stdlib");
  const str = $.getenv("__CHECK_STR");
  const re = /^\p{Emoji}?\s*\[[^\]]+\]:.*/u;
  $.exit(re.test(str) ? 0 : 1);
' > /dev/null 2>&1; then
  exit 0
fi

# Determine the commit intention based on the branch name prefix
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

# Extract the Jira issue code (e.g., PROJ-123) using grep with extended regex (-E)
# Then convert to uppercase using tr
# The regex matches:
# [^-\/]+ - One or more characters that are not a hyphen (-) or a forward slash (/) - this is the project key
# -[0-9]+ - A hyphen (-) followed by one or more digits (0-9) - this is the issue number
SCOPE=$(echo "$BRANCH_NAME" | grep -Eo '[^-\/]+-[0-9]+' | tr "[:lower:]" "[:upper:]")

# If no scope found, just leave the message unchanged
if [[ -z "$SCOPE" ]]; then
  exit 0
fi

# Extract leading word from message
LEADING_CHAR=$(echo "$MESSAGE" | awk '{print $1}')

# Download and parse Gitmoji list (no jq)
GITMOJI_JSON_URL="https://raw.githubusercontent.com/carloscuesta/gitmoji/refs/heads/master/packages/gitmojis/src/gitmojis.json"
CACHE_FILE="/tmp/gitmoji_cache.txt"

if [[ ! -f "$CACHE_FILE" || $(find "$CACHE_FILE" -mmin +60) ]]; then
  curl -s "$GITMOJI_JSON_URL" | grep -o '"emoji": *"[^"]*"' | sed 's/"emoji": *"\([^"]*\)"/\1/' > "$CACHE_FILE"
fi
GITMOJI_LIST=$(cat "$CACHE_FILE")

# Check if leading char is a valid Gitmoji
IS_GITMOJI=false
while IFS= read -r EMOJI; do
  if [[ "$LEADING_CHAR" == "$EMOJI" ]]; then
    IS_GITMOJI=true
    break
  fi
done <<< "$GITMOJI_LIST"

# Construct final commit message
if $IS_GITMOJI; then
  BODY=$(echo "$MESSAGE" | sed "s/^$LEADING_CHAR[[:space:]]*//")
  COMMIT_MSG="${LEADING_CHAR} [${SCOPE}]: ${BODY}"
else
  COMMIT_MSG="[${SCOPE}]: ${MESSAGE}"
fi

# Overwrite the commit message file with the new, prefixed message
if [[ $FILE != "" ]];
then
    echo "${COMMIT_MSG}" > "$FILE"
else
    echo "${COMMIT_MSG}"
fi